export function arrayToSudoku(array) {
    let sudoku = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (array[i][j] !== 0) {
                sudoku[i][j].add(array[i][j]);
            } else {
                for (let k = 1; k <= 9; k++) {
                    sudoku[i][j].add(k);
                }
            }
        }
    }

    return sudoku;
}

export function printSudoku(sudoku) {
    for (let i = 0; i < 9; i++) {
        let row = sudoku[i].map(cell => [...cell].join(', '));
        console.log(row.join(' | '));
    }
}

export function cloneSudoku(sudoku) {
    return sudoku.map(row => row.map(cell => new Set(cell)));
}

export function checkSudokuDifferent(sudoku1, sudoku2) {
    console.log('Checking...')
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku1[i][j].size !== sudoku2[i][j].size) {
                console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                break;
            }
            let flag = true;
            for (let num of sudoku1[i][j]) {
                if (!sudoku2[i][j].has(num)) {
                    console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                    flag = false;
                }
                if (!flag) {
                    break;
                }
            }
        }
    }
    console.log('Check done.')
}

class BaseSolver {
    getSolverName() {
        return "BaseSolver";
    }

    solver(sudoku) {
        throw new Error("Method 'solver' must be implemented.");
        return sudoku;
    }
}

export class SimpleSolver {
    getSolverName() {
        return "SimpleSolver";
    }

    static mergeSetsUsingSpread = (set1, set2) => new Set([...set1, ...set2]);

    solver(sudoku) {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (sudoku[i][j].size !== 1) {
                    // 两个set交集
                    // sudoku[i][j] = SimpleSolver.mergeSetsUsingSpread(sudoku[i][j], this.getUsedNumbers(sudoku, i, j));
                    const usedNumbers = this.getUsedNumbers(sudoku, i, j);
                    sudoku[i][j] = new Set([...sudoku[i][j]].filter(x => usedNumbers.has(x)));
                }
            }
        }

        return sudoku;
    }


    // 排除同行、同列和同宫已经填写的数字
    getUsedNumbers(sudoku, row, col) {
        // 获取指定行的所有数字
        const rowNumbers = new Set();
        for (let c = 0; c < 9; c++) {
            if (sudoku[row][c].size === 1) {
                // for (const num of this.board[row][c]) {
                //     rowNumbers.add(num);
                // }
                rowNumbers.add([...sudoku[row][c]][0]);
            }
        }

        // 获取指定列的所有数字
        const colNumbers = new Set();
        for (let r = 0; r < 9; r++) {
            if (sudoku[r][col].size === 1) {
                // for (const num of this.board[r][col]) {
                //     colNumbers.add(num);
                // }
                colNumbers.add([...sudoku[r][col]][0]);
            }
        }

        // 获取该行和列所在的九宫格的所有数字
        const gridNumbers = new Set();
        // 计算九宫格的左上角位置
        const gridStartRow = Math.floor(row / 3) * 3;
        const gridStartCol = Math.floor(col / 3) * 3;

        for (let r = gridStartRow; r < gridStartRow + 3; r++) {
            for (let c = gridStartCol; c < gridStartCol + 3; c++) {
                if (sudoku[r][c].size === 1) {
                    // for (const num of this.board[r][c]) {
                    //     gridNumbers.add(num);
                    // }
                    gridNumbers.add([...sudoku[r][c]][0]);
                }
            }
        }

        // 合并所有的数字
        const allNumbers = new Set([...rowNumbers, ...colNumbers, ...gridNumbers]);
        let ansNumber = new Set();
        for (let i = 1; i <= 9; i++) {
            if (!allNumbers.has(i)) {
                ansNumber.add(i);
            }
        }

        return ansNumber;
    }
}

class NakedPairsSolver extends BaseSolver {

    houses = [];

    init() {
        for (let row = 0; row < 9; row++) {
            let rowSet = new Set();
            for (let i = 0; i < 9; i++) {
                rowSet.add([row, i]);
            }
            this.houses.push(rowSet);
        }

        for (let col = 0; col < 9; col++) {
            let colSet = new Set();
            for (let i = 0; i < 9; i++) {
                colSet.add([i, col]);
            }
            this.houses.push(colSet);
        }

        for (let block = 0; block < 9; block++) {
            let blockSet = new Set();
            let rowStart = Math.floor(block / 3) * 3;
            let colStart = (block % 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    blockSet.add([rowStart + r, colStart + c]);
                }
            }
            this.houses.push(blockSet);
        }
    }

    solver(sudokuBoard) {
        this.init();

        this.board = sudokuBoard;

        this.prune(this.board.board);

        return this.board;
    }

    prune(sets) {
        let didSomething;
        do {
            didSomething = false;
            // 裸单一 (Naked Singles)
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (sets[i][j].size === 1) {
                        let digit = [...sets[i][j]][0];
                        for (let house of this.houses) {
                            if (house.has([i, j])) {
                                for (let [r, c] of house) {
                                    if (r !== i || c !== j) {
                                        sets[r][c].delete(digit);
                                        didSomething = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 隐藏单一 (Hidden Singles)
            for (let house of this.houses) {
                for (let digit = 1; digit <= 9; digit++) {
                    let digitPositions = [];
                    for (let [r, c] of house) {
                        if (sets[r][c].has(digit)) {
                            digitPositions.push([r, c]);
                        }
                    }
                    if (digitPositions.length === 1) {
                        let [r, c] = digitPositions[0];
                        if (sets[r][c].size > 1) {
                            sets[r][c] = new Set([digit]);
                            didSomething = true;
                        }
                    }
                }
            }
        } while (didSomething);
        return true;
    }

}