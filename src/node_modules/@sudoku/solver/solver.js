function arrayToSudoku(array) {
    let sudoku = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (array[i][j] !== 0) {
                sudoku[i][j].add(array[i][j]);
            } else {
                for (let k = 1; k <= 9; k++) {
                    sudoku[i][j].add(k);
                }
            }
        }
    }

    return sudoku;
}

function printSudoku(sudoku) {
    for (let i = 0; i < 9; i++) {
        let row = sudoku[i].map(cell => [...cell].join(', '));
        console.log(row.join(' | '));
    }
}

function cloneSudoku(sudoku) {
    return sudoku.map(row => row.map(cell => new Set(cell)));
}

function checkSudokuDifferent(sudoku1, sudoku2) {
    //console.log('Checking...')
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku1[i][j].size !== sudoku2[i][j].size) {
                console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                continue;
            }
            let flag = true;
            for (let num of sudoku1[i][j]) {
                if (!sudoku2[i][j].has(num)) {
                    console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                    flag = false;
                }
                if (!flag) {
                    break;
                }
            }
        }
    }
    //console.log('Check done.')
}

// 获取单元格的候选值
function getCandidates(sudoku, row, col) {
    return Array.from(sudoku[row][col]);
}

// 删除候选值
function removeCandidate(sudoku, row, col, candidate) {
    if (sudoku[row][col].size == 1) return;
    sudoku[row][col].delete(candidate);
    // console.log("After:", row, col, sudoku[row][col]);
}

// 检查两个单元格是否在同一行、列或宫
function areBuddies(row1, col1, row2, col2) {
    return row1 === row2 || col1 === col2 || getBoxIndex(row1, col1) === getBoxIndex(row2, col2);
}

// 获取单元格所在的宫索引
function getBoxIndex(row, col) {
    return Math.floor(row / 3) * 3 + Math.floor(col / 3);
}

// 获取单元格的候选值数量
function getCandidateCount(sudoku, row, col) {
    return sudoku[row][col].size;
}

// 获取单元格的候选值掩码
function getCandidateMask(sudoku, row, col) {
    return Array.from(sudoku[row][col]).reduce((mask, cand) => mask | (1 << cand), 0);
}

// 获取候选值掩码的数量
function getMaskCount(mask) {
    return mask.toString(2).split('1').length - 1;
}

class BaseSolver {
    getSolverName() {
        return "BaseSolver";
    }

    solver(sudoku) {
        throw new Error("Method 'solver' must be implemented.");
        return sudoku;
    }
}

class SimpleSolver extends BaseSolver {
    getSolverName() {
        return "SimpleSolver";
    }

    static mergeSetsUsingSpread = (set1, set2) => new Set([...set1, ...set2]);

    solver(sudoku) {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (sudoku[i][j].size !== 1) {
                    // 两个set交集
                    // sudoku[i][j] = SimpleSolver.mergeSetsUsingSpread(sudoku[i][j], this.getUsedNumbers(sudoku, i, j));
                    const unUsedNumbers = this.getUsedNumbers(sudoku, i, j);
                    // sudoku[i][j] = new Set([...sudoku[i][j]].filter(x => unUsedNumbers.has(x)));
                    sudoku[i][j] = unUsedNumbers;
                }
            }
        }

        return sudoku;
    }


    // 排除同行、同列和同宫已经填写的数字
    getUsedNumbers(sudoku, row, col) {
        // 获取指定行的所有数字
        const rowNumbers = new Set();
        for (let c = 0; c < 9; c++) {
            if (sudoku[row][c].size === 1) {
                rowNumbers.add([...sudoku[row][c]][0]);
            }
        }

        // 获取指定列的所有数字
        const colNumbers = new Set();
        for (let r = 0; r < 9; r++) {
            if (sudoku[r][col].size === 1) {
                colNumbers.add([...sudoku[r][col]][0]);
            }
        }

        // 获取该行和列所在的九宫格的所有数字
        const gridNumbers = new Set();
        // 计算九宫格的左上角位置
        const gridStartRow = Math.floor(row / 3) * 3;
        const gridStartCol = Math.floor(col / 3) * 3;

        for (let r = gridStartRow; r < gridStartRow + 3; r++) {
            for (let c = gridStartCol; c < gridStartCol + 3; c++) {
                if (sudoku[r][c].size === 1) {
                    gridNumbers.add([...sudoku[r][c]][0]);
                }
            }
        }

        // 合并所有的数字
        const allNumbers = new Set([...rowNumbers, ...colNumbers, ...gridNumbers]);
        let ansNumber = new Set();
        for (let i = 1; i <= 9; i++) {
            if (!allNumbers.has(i)) {
                ansNumber.add(i);
            }
        }

        return ansNumber;
    }
}

class NakedPairsSolver extends BaseSolver {

    solver(sudoku) {
        // 先找到所有的双值单元格
        const pairs = [];

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (sudoku[row][col].size === 2) {
                    pairs.push([row, col]);
                }
            }
        }

        // 检查双值单元格是否在同一行、列或宫
        for (let i = 0; i < pairs.length; i++) {
            const [row1, col1] = pairs[i];
            for (let j = i + 1; j < pairs.length; j++) {
                const [row2, col2] = pairs[j];
                if (row1 == row2 && col1 == col2) continue;
                if (row1 === row2 || col1 === col2 || getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) {
                    if (sudoku[row1][col1].size === 2 && sudoku[row1][col1].size === sudoku[row2][col2].size) {
                        // 检查两个单元格的候选值是否相同
                        let same = true;
                        sudoku[row1][col1].forEach(cand => {
                                if (!sudoku[row2][col2].has(cand)) {
                                    same = false;
                                }
                            }
                        );
                        if (!same) {
                            break;
                        }

                        // 如果是行相同，就删除行中其他单元格的候选值
                        if (row1 === row2) {
                            for (let col = 0; col < 9; col++) {
                                if (col !== col1 && col !== col2) {
                                    Array.from(sudoku[row1][col1]).forEach(cand => {
                                        removeCandidate(sudoku, row1, col, cand);
                                    });
                                }
                            }
                        }

                        // 如果是列相同，就删除列中其他单元格的候选值
                        if (col1 === col2) {
                            for (let row = 0; row < 9; row++) {
                                if (row !== row1 && row !== row2) {
                                    Array.from(sudoku[row1][col1]).forEach(cand => {
                                        removeCandidate(sudoku, row, col1, cand);
                                    });
                                }
                            }
                        }

                        // 如果是宫相同，就删除宫中其他单元格的候选值
                        if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) {
                            const boxIndex = getBoxIndex(row1, col1);
                            for (let row = 0; row < 9; row++) {
                                for (let col = 0; col < 9; col++) {
                                    if (getBoxIndex(row, col) === boxIndex && (row !== row1 || col !== col1) && (row !== row2 || col !== col2)) {
                                        Array.from(sudoku[row1][col1]).forEach(cand => {
                                            removeCandidate(sudoku, row, col, cand);
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        return sudoku;
    }

}

class MiscellaneousSolver extends BaseSolver {
    getSueDeCoq(sudoku) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const boxIndex = getBoxIndex(row, col);
                const intersection = new Set();
                const intersectionCandidates = new Set();

                // 找到行/列和宫的交集
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (getBoxIndex(r, c) === boxIndex && (r === row || c === col)) {
                            intersection.add([r, c]);
                            getCandidates(sudoku, r, c).forEach(cand => intersectionCandidates.add(cand));
                        }
                    }
                }

                // 检查交集的候选值数量是否满足 Sue de Coq 的条件
                if (intersectionCandidates.size < intersection.size + 2) continue;

                // 检查行/列和宫中的额外单元格
                const rowExtra = new Set();
                const rowExtraCandidates = new Set();
                const boxExtra = new Set();
                const boxExtraCandidates = new Set();

                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (r === row || c === col) {
                            if (!intersection.has([r, c])) {
                                rowExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => rowExtraCandidates.add(cand));
                            }
                        }
                        if (getBoxIndex(r, c) === boxIndex) {
                            if (!intersection.has([r, c])) {
                                boxExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => boxExtraCandidates.add(cand));
                            }
                        }
                    }
                }

                // 检查是否满足 Sue de Coq 的条件
                const rowExtraValid = Array.from(rowExtraCandidates).every(cand => intersectionCandidates.has(cand));
                const boxExtraValid = Array.from(boxExtraCandidates).every(cand => intersectionCandidates.has(cand));

                if (rowExtraValid && boxExtraValid) {
                    // 删除候选值
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (!intersection.has([r, c]) && (r === row || c === col || getBoxIndex(r, c) === boxIndex)) {
                                Array.from(intersectionCandidates).forEach(cand => {
                                    if (!rowExtraCandidates.has(cand) && !boxExtraCandidates.has(cand)) {
                                        removeCandidate(sudoku, r, c, cand);
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    solver(sudoku) {
        this.getSueDeCoq(sudoku)
        return sudoku
    }

    getSolverName() {
        return "Miscellaneous Solver"
    }

    test() {
        const sudoku = [
            [6, 0, 0, 0, 0, 0, 0, 0, 8],
            [5, 0, 0, 9, 0, 8, 0, 0, 7],
            [8, 2, 0, 0, 0, 1, 0, 3, 0],
            [3, 4, 0, 2, 0, 9, 0, 8, 0],
            [2, 0, 0, 0, 8, 0, 3, 0, 0],
            [1, 8, 0, 3, 0, 7, 0, 2, 5],
            [7, 5, 0, 4, 0, 0, 0, 9, 2],
            [9, 0, 0, 0, 0, 5, 0, 0, 4],
            [4, 0, 0, 0, 9, 0, 0, 0, 3]
        ];

        let sudokuBoard = new SudokuBoard(sudoku);
    }
}

class XYWingSolver extends BaseSolver {

    getSolverName() {
        return "XYWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 2) continue; // 必须是双值单元格

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享一个候选值
                        const sharedCandidates = candidates1.filter(c => candidates2.includes(c));
                        if (sharedCandidates.length !== 1) continue;

                        const z = sharedCandidates[0];
                        const x = candidates1.find(c => c !== z);
                        const y = candidates2.find(c => c !== z);

                        // 寻找第三个单元格
                        for (let row3 = 0; row3 < 9; row3++) {
                            for (let col3 = 0; col3 < 9; col3++) {
                                if (row3 === row1 && col3 === col1) continue;
                                if (row3 === row2 && col3 === col2) continue;
                                const candidates3 = getCandidates(sudoku, row3, col3);
                                if (candidates3.length !== 2) continue; // 必须是双值单元格

                                // 检查第三个单元格是否包含 y 和 z
                                if (!candidates3.includes(y) || !candidates3.includes(z)) continue;

                                // 检查第三个单元格是否与第一个单元格共享 y
                                if (!areBuddies(row1, col1, row3, col3)) continue;

                                // 找到 XY-Wing，删除候选值 z
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row2, col2) && areBuddies(row, col, row3, col3)) {
                                            removeCandidate(sudoku, row, col, z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }

}

class XYZWingSolver extends BaseSolver {
    getSolverName() {
        return "XYZWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 3) continue; // 必须是三值单元格

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享两个候选值
                        const sharedCandidates = candidates1.filter(c => candidates2.includes(c));
                        if (sharedCandidates.length !== 2) continue;

                        const z = sharedCandidates[0];
                        const x = candidates1.find(c => c !== z);
                        const y = candidates2.find(c => c !== z);

                        // 寻找第三个单元格
                        for (let row3 = 0; row3 < 9; row3++) {
                            for (let col3 = 0; col3 < 9; col3++) {
                                if (row3 === row1 && col3 === col1) continue;
                                if (row3 === row2 && col3 === col2) continue;
                                const candidates3 = getCandidates(sudoku, row3, col3);
                                if (candidates3.length !== 2) continue; // 必须是双值单元格

                                // 检查第三个单元格是否包含 y 和 z
                                if (!candidates3.includes(y) || !candidates3.includes(z)) continue;

                                // 检查第三个单元格是否与第一个单元格共享 y
                                if (!areBuddies(row1, col1, row3, col3)) continue;

                                // 找到 XYZ-Wing，删除候选值 z
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row2, col2) && areBuddies(row, col, row3, col3)) {
                                            removeCandidate(sudoku, row, col, z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }
}

class WWingSolver extends BaseSolver {
    getSolverName() {
        return "WWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 2) continue; // 必须是双值单元格

                const [x, y] = candidates1;

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享候选值
                        if (candidates2.includes(x) && candidates2.includes(y)) {
                            // 寻找强连接
                            if (this.hasStrongLink(sudoku, x, row1, col1, row2, col2)) {
                                // 删除候选值 x
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row1, col1) && areBuddies(row, col, row2, col2)) {
                                            removeCandidate(sudoku, row, col, x);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return sudoku;
    }

    hasStrongLink(sudoku, candidate, row1, col1, row2, col2) {
        // 检查行、列或宫中是否存在强连接
        for (let unit = 0; unit < 9; unit++) {
            const row = Math.floor(unit / 3) * 3;
            const col = (unit % 3) * 3;
            let count = 0;
            for (let r = row; r < row + 3; r++) {
                for (let c = col; c < col + 3; c++) {
                    if (getCandidates(sudoku, r, c).includes(candidate)) {
                        count++;
                    }
                }
            }
            if (count === 2) return true;
        }
        return false;
    }
}

export {
    arrayToSudoku, cloneSudoku, printSudoku, checkSudokuDifferent,
    SimpleSolver, NakedPairsSolver, MiscellaneousSolver, XYWingSolver, XYZWingSolver, WWingSolver
}