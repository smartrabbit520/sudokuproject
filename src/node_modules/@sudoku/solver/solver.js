function arrayToSudoku(array) {
    let sudoku = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (array[i][j] !== 0) {
                sudoku[i][j].add(array[i][j]);
            } else {
                for (let k = 1; k <= 9; k++) {
                    sudoku[i][j].add(k);
                }
            }
        }
    }

    return sudoku;
}

function checkSudokuStatus(sudoku) {
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku[i][j].size !== 1) {
                console.log('存在未填写的单元格');
                return false;
            }
        }
    }

    // 如果已经全部填写，检查是否符合数独规则
    let rowSet = new Set();
    let colSet = new Set();
    let boxSet = new Set();
    for (let i = 0; i < 9; i++) {
        rowSet.clear();
        colSet.clear();
        boxSet.clear();
        for (let j = 0; j < 9; j++) {
            if (rowSet.has([...sudoku[i][j]][0])) {
                console.log(`第${i}行重复`);
                return false;
            }
            rowSet.add([...sudoku[i][j]][0]);
            if (colSet.has([...sudoku[j][i]][0])) {
                console.log(`第${i}列重复`);
                return false;
            }
            colSet.add([...sudoku[j][i]][0]);

            let boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
            if (boxSet.has([...sudoku[i][j]][0])) {
                console.log(`第${boxIndex}宫重复`);
                return false;
            }
            boxSet.add([...sudoku[i][j]][0]);
        }
    }

    console.log('数独通过检查');
    return true;
}

function printSudoku(sudoku) {
    const cellWidth = 11; // 调整此值以适应坐标加上内容的长度
    const separator = ' | ';
    const rowSeparator = '-'.repeat(9 * (cellWidth + separator.length) - separator.length);

    for (let i = 0; i < 9; i++) {
        if (i % 3 === 0 && i !== 0) console.log(rowSeparator); // 打印行之间的分隔线

        let row = sudoku[i].map((cell, colIndex) => {
            // 如果是 Set 类型，将其转换为数组并排序；否则假设它已经是数组
            const cellContent = Array.from(cell).sort((a, b) => a - b);
            // 创建一个定宽的字符串，内容居中，并且前置坐标
            return `(${i},${colIndex})`.padEnd(6) +
                (cellContent.length > 0
                    ? cellContent.join('').padStart(Math.floor((cellWidth - 6) / 2) + cellContent.join('').length / 2)
                        .padEnd(cellWidth - 6)
                    : ''.padStart(cellWidth - 6));
        });

        console.log(row.join(separator));
    }
}

function cloneSudoku(sudoku) {
    return sudoku.map(row => row.map(cell => new Set(cell)));
}

function stringToSudoku(string) {
    let sudoku = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            let num = parseInt(string[i * 9 + j]);
            if (num !== 0) {
                sudoku[i][j].add(num);
            } else {
                for (let k = 1; k <= 9; k++) {
                    sudoku[i][j].add(k);
                }
            }
        }
    }

    return sudoku;
}

function checkSudokuDifferent(sudoku1, sudoku2, print = true) {
    //console.log('Checking...')
    let isDifferent = false;
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku1[i][j].size !== sudoku2[i][j].size) {
                if (print)
                    console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                isDifferent = true;
                continue;
            }
            let flag = true;
            for (let num of sudoku1[i][j]) {
                if (!sudoku2[i][j].has(num)) {
                    if (print)
                        console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                    isDifferent = true;
                    flag = false;
                }
                if (!flag) {
                    break;
                }
            }
        }
    }
    //console.log('Check done.')
    return isDifferent;
}

function checkSudokuDifferentWithString(sudoku1, sudoku2, print = true, solverName, changeArrays) {
    //console.log('Checking...')
    let isDifferent = false;
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku1[i][j].size !== sudoku2[i][j].size) {
                if (print)
                    console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                changeArrays[i][j].push(solverName);
                isDifferent = true;
                continue;
            }
            let flag = true;
            for (let num of sudoku1[i][j]) {
                if (!sudoku2[i][j].has(num)) {
                    if (print)
                        console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                    changeArrays[i][j].push(solverName);
                    isDifferent = true;
                    flag = false;
                }
                if (!flag) {
                    break;
                }
            }
        }
    }
    //console.log('Check done.')
    return isDifferent;
}

// 获取单元格的候选值
function getCandidates(sudoku, row, col) {
    return Array.from(sudoku[row][col]);
}

// 删除候选值
function removeCandidate(sudoku, row, col, candidate) {
    if (sudoku[row][col].size == 1) return;
    sudoku[row][col].delete(candidate);
}

// 检查两个单元格是否在同一行、列或宫
function areBuddies(row1, col1, row2, col2) {
    return row1 === row2 || col1 === col2 || getBoxIndex(row1, col1) === getBoxIndex(row2, col2);
}

// 获取单元格所在的宫索引
function getBoxIndex(row, col) {
    return Math.floor(row / 3) * 3 + Math.floor(col / 3);
}

// 获取单元格的候选值数量
function getCandidateCount(sudoku, row, col) {
    return sudoku[row][col].size;
}

// 获取单元格的候选值掩码
function getCandidateMask(sudoku, row, col) {
    return Array.from(sudoku[row][col]).reduce((mask, cand) => mask | (1 << cand), 0);
}

// 获取候选值掩码的数量
function getMaskCount(mask) {
    return mask.toString(2).split('1').length - 1;
}

class BaseSolver {
    getSolverName() {
        return "BaseSolver";
    }

    solver(sudoku) {
        throw new Error("Method 'solver' must be implemented.");
        return sudoku;
    }
}

class SimpleSolver extends BaseSolver {
    getSolverName() {
        return "SimpleSolver";
    }

    static mergeSetsUsingSpread = (set1, set2) => new Set([...set1, ...set2]);

    solver(sudoku) {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (sudoku[i][j].size !== 1) {
                    // 两个set交集
                    // sudoku[i][j] = SimpleSolver.mergeSetsUsingSpread(sudoku[i][j], this.getUsedNumbers(sudoku, i, j));
                    //const unUsedNumbers = this.getUsedNumbers(sudoku, i, j);
                    //sudoku[i][j] = new Set([...sudoku[i][j]].filter(x => unUsedNumbers.has(x)));
                    sudoku[i][j] = this.getUsedNumbers(sudoku, i, j);
                }
            }
        }

        return sudoku;
    }


    // 排除同行、同列和同宫已经填写的数字
    getUsedNumbers(sudoku, row, col) {
        // 获取指定行的所有数字
        let rowNumbers = new Set();
        for (let c = 0; c < 9; c++) {
            if (sudoku[row][c].size === 1) {
                rowNumbers.add([...sudoku[row][c]][0]);
            }
        }

        // 获取指定列的所有数字
        let colNumbers = new Set();
        for (let r = 0; r < 9; r++) {
            if (sudoku[r][col].size === 1) {
                colNumbers.add([...sudoku[r][col]][0]);
            }
        }

        // 获取该行和列所在的九宫格的所有数字
        let gridNumbers = new Set();
        // 计算九宫格的左上角位置
        const gridStartRow = Math.floor(row / 3) * 3;
        const gridStartCol = Math.floor(col / 3) * 3;

        for (let r = gridStartRow; r < gridStartRow + 3; r++) {
            for (let c = gridStartCol; c < gridStartCol + 3; c++) {
                if (sudoku[r][c].size === 1) {
                    gridNumbers.add([...sudoku[r][c]][0]);
                }
            }
        }

        // 合并所有的数字
        const allNumbers = new Set([...rowNumbers, ...colNumbers, ...gridNumbers]);
        let cloneSet = new Set();
        // 拷贝sudoku[row][col]
        for (let num of sudoku[row][col]) {
            cloneSet.add(num);
        }
        // 筛选出在sudoku[row][col]中，但是不在allNumbers中的数字
        let ans = new Set([...sudoku[row][col]].filter(x => !allNumbers.has(x)));
        if (ans.size === 0) {
            return cloneSet;
        }
        return ans;
    }
}

class NakedPairsSolver extends BaseSolver {

    solver(sudoku) {
        // 先找到所有的双值单元格
        const pairs = [];

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (sudoku[row][col].size === 2) {
                    pairs.push([row, col]);
                }
            }
        }

        // 检查双值单元格是否在同一行、列或宫
        for (let i = 0; i < pairs.length; i++) {
            const [row1, col1] = pairs[i];
            for (let j = i + 1; j < pairs.length; j++) {
                const [row2, col2] = pairs[j];
                if (row1 == row2 && col1 == col2) continue;
                if (row1 === row2 || col1 === col2 || getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) {
                    if (sudoku[row1][col1].size === 2 && sudoku[row1][col1].size === sudoku[row2][col2].size) {
                        // 检查两个单元格的候选值是否相同
                        let same = true;
                        sudoku[row1][col1].forEach(cand => {
                                if (!sudoku[row2][col2].has(cand)) {
                                    same = false;
                                }
                            }
                        );
                        if (!same) {
                            break;
                        }

                        // 如果是行相同，就删除行中其他单元格的候选值
                        if (row1 === row2) {
                            for (let col = 0; col < 9; col++) {
                                if (col !== col1 && col !== col2) {
                                    Array.from(sudoku[row1][col1]).forEach(cand => {
                                        removeCandidate(sudoku, row1, col, cand);
                                    });
                                }
                            }
                        }

                        // 如果是列相同，就删除列中其他单元格的候选值
                        if (col1 === col2) {
                            for (let row = 0; row < 9; row++) {
                                if (row !== row1 && row !== row2) {
                                    Array.from(sudoku[row1][col1]).forEach(cand => {
                                        removeCandidate(sudoku, row, col1, cand);
                                    });
                                }
                            }
                        }

                        // 如果是宫相同，就删除宫中其他单元格的候选值
                        if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) {
                            const boxIndex = getBoxIndex(row1, col1);
                            for (let row = 0; row < 9; row++) {
                                for (let col = 0; col < 9; col++) {
                                    if (getBoxIndex(row, col) === boxIndex && (row !== row1 || col !== col1) && (row !== row2 || col !== col2)) {
                                        Array.from(sudoku[row1][col1]).forEach(cand => {
                                            removeCandidate(sudoku, row, col, cand);
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        return sudoku;
    }

}

class NakedTriplesSolver extends BaseSolver {
    solver(sudoku) {
        // 先找到所有的三值单元格
        const triples = [];

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (sudoku[row][col].size >= 2 && sudoku[row][col].size <= 3) {
                    triples.push([row, col]);
                }
            }
        }

        // 检查三值单元格是否在同一行、列或宫
        for (let i = 0; i < triples.length; i++) {
            for (let j = i + 1; j < triples.length; j++) {
                for (let k = j + 1; k < triples.length; k++) {
                    // 先检查三个set的值只有三个
                    const [row1, col1] = triples[i];
                    const [row2, col2] = triples[j];
                    const [row3, col3] = triples[k];

                    let allNumbers = new Set();
                    for (let num of sudoku[row1][col1]) {
                        allNumbers.add(num);

                    }
                    for (let num of sudoku[row2][col2]) {
                        allNumbers.add(num);
                    }
                    for (let num of sudoku[row3][col3]) {
                        allNumbers.add(num);
                    }
                    if (allNumbers.size !== 3) {
                        continue;
                    }

                    // 检查三个单元格是否在同一行、列或宫
                    if (row1 === row2 && row1 === row3) {
                        // 如果是行相同，就删除行中其他单元格的候选值
                        for (let col = 0; col < 9; col++) {
                            if (col !== col1 && col !== col2 && col !== col3) {
                                Array.from(allNumbers).forEach(cand => {
                                    removeCandidate(sudoku, row1, col, cand);
                                });
                            }
                        }
                    }

                    if (col1 === col2 && col1 === col3) {
                        // 如果是列相同，就删除列中其他单元格的候选值
                        for (let row = 0; row < 9; row++) {
                            if (row !== row1 && row !== row2 && row !== row3) {
                                Array.from(allNumbers).forEach(cand => {
                                    removeCandidate(sudoku, row, col1, cand);
                                });
                            }
                        }
                    }

                    if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2) && getBoxIndex(row1, col1) === getBoxIndex(row3, col3)) {
                        // 如果是宫相同，就删除宫中其他单元格的候选值
                        const boxIndex = getBoxIndex(row1, col1);
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                if (getBoxIndex(row, col) === boxIndex && (row !== row1 || col !== col1) && (row !== row2 || col !== col2) && (row !== row3 || col !== col3)) {
                                    Array.from(allNumbers).forEach(cand => {
                                        removeCandidate(sudoku, row, col, cand);
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }

    getSolverName() {
        return "NakedTriplesSolver";
    }
}

class NakedQuadsSolver extends BaseSolver {
    solver(sudoku) {
        // 先找到所有的三值单元格
        const quads = [];

        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (sudoku[row][col].size >= 2 && sudoku[row][col].size <= 4) {
                    quads.push([row, col]);
                }
            }
        }

        // 检查三值单元格是否在同一行、列或宫
        for (let i = 0; i < quads.length; i++) {
            for (let j = i + 1; j < quads.length; j++) {
                for (let k = j + 1; k < quads.length; k++) {
                    for (let l = k + 1; l < quads.length; l++) {
                        // 先检查三个set的值只有三个
                        const [row1, col1] = quads[i];
                        const [row2, col2] = quads[j];
                        const [row3, col3] = quads[k];
                        const [row4, col4] = quads[l];

                        let allNumbers = new Set();
                        for (let num of sudoku[row1][col1]) {
                            allNumbers.add(num);

                        }
                        for (let num of sudoku[row2][col2]) {
                            allNumbers.add(num);
                        }
                        for (let num of sudoku[row3][col3]) {
                            allNumbers.add(num);
                        }
                        for (let num of sudoku[row4][col4]) {
                            allNumbers.add(num);
                        }
                        if (allNumbers.size !== 4) {
                            continue;
                        }

                        // 检查四个单元格是否在同一行、列或宫
                        if (row1 === row2 && row1 === row3 && row1 === row4) {
                            // 如果是行相同，就删除行中其他单元格的候选值
                            for (let col = 0; col < 9; col++) {
                                if (col !== col1 && col !== col2 && col !== col3 && col !== col4) {
                                    Array.from(allNumbers).forEach(cand => {
                                        removeCandidate(sudoku, row1, col, cand);
                                    });
                                }
                            }
                        }

                        if (col1 === col2 && col1 === col3 && col1 === col4) {
                            // 如果是列相同，就删除列中其他单元格的候选值
                            for (let row = 0; row < 9; row++) {
                                if (row !== row1 && row !== row2 && row !== row3 && row !== row4) {
                                    Array.from(allNumbers).forEach(cand => {
                                        removeCandidate(sudoku, row, col1, cand);
                                    });
                                }
                            }
                        }

                        if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2) && getBoxIndex(row1, col1) === getBoxIndex(row3, col3) && getBoxIndex(row1, col1) === getBoxIndex(row4, col4)) {
                            // 如果是宫相同，就删除宫中其他单元格的候选值
                            const boxIndex = getBoxIndex(row1, col1);
                            for (let row = 0; row < 9; row++) {
                                for (let col = 0; col < 9; col++) {
                                    if (getBoxIndex(row, col) === boxIndex && (row !== row1 || col !== col1) && (row !== row2 || col !== col2) && (row !== row3 || col !== col3) && (row !== row4 || col !== col4)) {
                                        Array.from(allNumbers).forEach(cand => {
                                            removeCandidate(sudoku, row, col, cand);
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }

    getSolverName() {
        return "NakedTriplesSolver";
    }
}

class MiscellaneousSolver extends BaseSolver {
    getSueDeCoq(sudoku) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const boxIndex = getBoxIndex(row, col);
                const intersection = new Set();
                const intersectionCandidates = new Set();

                // 找到行/列和宫的交集
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (getBoxIndex(r, c) === boxIndex && (r === row || c === col)) {
                            intersection.add([r, c]);
                            getCandidates(sudoku, r, c).forEach(cand => intersectionCandidates.add(cand));
                        }
                    }
                }

                // 检查交集的候选值数量是否满足 Sue de Coq 的条件
                if (intersectionCandidates.size < intersection.size + 2) continue;

                // 检查行/列和宫中的额外单元格
                const rowExtra = new Set();
                const rowExtraCandidates = new Set();
                const boxExtra = new Set();
                const boxExtraCandidates = new Set();

                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (r === row || c === col) {
                            if (!intersection.has([r, c])) {
                                rowExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => rowExtraCandidates.add(cand));
                            }
                        }
                        if (getBoxIndex(r, c) === boxIndex) {
                            if (!intersection.has([r, c])) {
                                boxExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => boxExtraCandidates.add(cand));
                            }
                        }
                    }
                }

                // 检查是否满足 Sue de Coq 的条件
                const rowExtraValid = Array.from(rowExtraCandidates).every(cand => intersectionCandidates.has(cand));
                const boxExtraValid = Array.from(boxExtraCandidates).every(cand => intersectionCandidates.has(cand));

                if (rowExtraValid && boxExtraValid) {
                    // 删除候选值
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (!intersection.has([r, c]) && (r === row || c === col || getBoxIndex(r, c) === boxIndex)) {
                                Array.from(intersectionCandidates).forEach(cand => {
                                    if (!rowExtraCandidates.has(cand) && !boxExtraCandidates.has(cand)) {
                                        removeCandidate(sudoku, r, c, cand);
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    solver(sudoku) {
        this.getSueDeCoq(sudoku)
        return sudoku
    }

    getSolverName() {
        return "Miscellaneous Solver"
    }

    test() {
        const sudoku = [
            [6, 0, 0, 0, 0, 0, 0, 0, 8],
            [5, 0, 0, 9, 0, 8, 0, 0, 7],
            [8, 2, 0, 0, 0, 1, 0, 3, 0],
            [3, 4, 0, 2, 0, 9, 0, 8, 0],
            [2, 0, 0, 0, 8, 0, 3, 0, 0],
            [1, 8, 0, 3, 0, 7, 0, 2, 5],
            [7, 5, 0, 4, 0, 0, 0, 9, 2],
            [9, 0, 0, 0, 0, 5, 0, 0, 4],
            [4, 0, 0, 0, 9, 0, 0, 0, 3]
        ];

        let sudokuBoard = new SudokuBoard(sudoku);
    }
}

class XYWingSolver extends BaseSolver {

    getSolverName() {
        return "XYWingSolver";
    }

    solver(sudoku) {

        // 遍历所有行
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                // 获取当前单元格的候选值
                const candidates = getCandidates(sudoku, i, j);
                if (candidates.length !== 2) continue;

                // 遍历当前行的其他单元格
                for (let k = 0; k < 9; k++) {
                    if (k === j) continue;
                    // 不能在同一个宫中
                    if (getBoxIndex(i, j) === getBoxIndex(i, k)) continue;

                    const otherCandidates = getCandidates(sudoku, i, k);
                    if (otherCandidates.length !== 2) continue;

                    // 找到共享的候选值
                    const sharedCandidates = candidates.filter(c => otherCandidates.includes(c));
                    if (sharedCandidates.length !== 1) continue;

                    const x = sharedCandidates[0];
                    const y = candidates.find(c => c !== x);
                    const z = otherCandidates.find(c => c !== x);

                    // 遍历[i,j]同一个宫的其他单元格
                    let b3List = [];
                    for (let r = Math.floor(i / 3) * 3; r < Math.floor(i / 3) * 3 + 3; r++) {
                        for (let c = Math.floor(j / 3) * 3; c < Math.floor(j / 3) * 3 + 3; c++) {
                            if (r === i && c === j) continue;
                            if (r === i && c === k) continue;
                            if (r === i) continue; // 排除与b1在同一行的情况

                            const otherCandidates = getCandidates(sudoku, r, c);
                            if (otherCandidates.length !== 2) continue;

                            if (otherCandidates.includes(y) && otherCandidates.includes(z)) {
                                b3List.push([r, c]);
                            }
                        }
                    }

                    if (b3List.length === 1) {
                        const [r, c] = b3List[0];
                        // 遍历b2所在的宫，移除z
                        for (let row = Math.floor(i / 3) * 3; row < Math.floor(i / 3) * 3 + 3; row++) {
                            for (let col = Math.floor(k / 3) * 3; col < Math.floor(k / 3) * 3 + 3; col++) {
                                if (row === r) continue; // 排除与b3在同一行的情况
                                removeCandidate(sudoku, row, col, z);
                            }
                        }

                        // 遍历b3所在的行，移除z
                        for (let col = 0; col < 9; col++) {
                            removeCandidate(sudoku, r, col, z);
                        }
                    }
                }
            }
        }

        return sudoku;
    }
}

class YXWingSolver extends BaseSolver {

    getSolverName() {
        return "YXWingSolver";
    }

    solver(sudoku) {
        // 遍历所有列
        for (let j = 0; j < 9; j++) {
            for (let i = 0; i < 9; i++) {
                // 获取当前单元格的候选值
                const candidates = getCandidates(sudoku, i, j);
                if (candidates.length !== 2) continue;

                // 遍历当前列的其他单元格
                for (let k = 0; k < 9; k++) {
                    if (k === i) continue;
                    // 不能在同一个宫中
                    if (getBoxIndex(i, j) === getBoxIndex(k, j)) continue;

                    const otherCandidates = getCandidates(sudoku, k, j);
                    if (otherCandidates.length !== 2) continue;

                    // 找到共享的候选值
                    const sharedCandidates = candidates.filter(c => otherCandidates.includes(c));
                    if (sharedCandidates.length !== 1) continue;

                    const x = sharedCandidates[0];
                    const y = candidates.find(c => c !== x);
                    const z = otherCandidates.find(c => c !== x);

                    // 遍历[i,j]同一个宫的其他单元格
                    let b3List = [];
                    for (let r = Math.floor(i / 3) * 3; r < Math.floor(i / 3) * 3 + 3; r++) {
                        for (let c = Math.floor(j / 3) * 3; c < Math.floor(j / 3) * 3 + 3; c++) {
                            if (r === i && c === j) continue;
                            if (r === k && c === j) continue;

                            const otherCandidates = getCandidates(sudoku, r, c);
                            if (otherCandidates.length !== 2) continue;

                            if (otherCandidates.includes(y) && otherCandidates.includes(z)) {
                                b3List.push([r, c]);
                            }
                        }
                    }

                    if (b3List.length === 1) {
                        const [r, c] = b3List[0];
                        // 遍历9*9，找到与[i,k]同宫以及和[r,c]同行的单元格
                        for (let row = 0; row < 9; row++) {
                            for (let col = 0; col < 9; col++) {
                                if (getBoxIndex(row, col) === getBoxIndex(i, j) && col === c) {
                                    removeCandidate(sudoku, row, col, z);
                                    return sudoku;  // 找到后结束
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }
}

class XYZWingSolver extends BaseSolver {
    getSolverName() {
        return "XYZWingSolver";
    }

    solver(sudoku) {
        // 分别遍历9个宫
        for (let boxIndex = 0; boxIndex < 9; boxIndex++) {
            const boxCells = [];
            for (let row = Math.floor(boxIndex / 3) * 3; row < Math.floor(boxIndex / 3) * 3 + 3; row++) {
                for (let col = Math.floor(boxIndex % 3) * 3; col < Math.floor(boxIndex % 3) * 3 + 3; col++) {
                    boxCells.push([row, col]);
                }
            }

            // 遍历宫中的每一个单元格
            for (let i = 0; i < boxCells.length; i++) {
                const [row1, col1] = boxCells[i];
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 3) continue;

                this.findB2AndClear(sudoku, row1, col1);
            }
        }

        return sudoku;
    }

    isB2Box(sudoku, row1, col1, row2, col2) {
        // b1和b2不是同一个宫，并且b2的候选值只有两个，且都在b1中
        if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) return false;
        const candidates1 = getCandidates(sudoku, row1, col1);
        const candidates2 = getCandidates(sudoku, row2, col2);
        if (candidates2.length !== 2) return false;
        return candidates2.every(cand => candidates1.includes(cand));
    }

    findB2AndClear(sudoku, row1, col1) {
        // 遍历9*9
        for (let row2 = 0; row2 < 9; row2++) {
            for (let col2 = 0; col2 < 9; col2++) {
                if (row1 === row2 && col1 === col2) continue;
                if (this.isB2Box(sudoku, row1, col1, row2, col2)) {
                    // 找到b2，清除b2中的候选值
                    const candidates2 = getCandidates(sudoku, row2, col2);

                    // 获取在b1但不在b2中的候选值
                    const candidates1 = getCandidates(sudoku, row1, col1);
                    const extraCandidates = candidates1.filter(cand => !candidates2.includes(cand));
                    // 取第一个额外候选值
                    const b = extraCandidates[0];
                    // 遍历instersection，清除其他单元格的候选值
                    for (let c of candidates2) {
                        this.findB3AndClear(sudoku, row1, row2, b, c)
                    }
                }
            }
        }
    }

    findB3AndClear(sudoku, row1, col1, b, c) {
        // 遍历9*9
        for (let row3 = 0; row3 < 9; row3++) {
            for (let col3 = 0; col3 < 9; col3++) {
                if (row1 === row3 && col1 === col3) continue;
                // b3不和b1在同一行或同一列
                if (row1 === row3 || col1 === col3) continue;
                // 候选值只有两个，且是b,c
                const candidates3 = getCandidates(sudoku, row3, col3);
                if (candidates3.length !== 2) continue;
                if (!candidates3.includes(b) || !candidates3.includes(c)) continue;

                // 遍历9*9，找到与b1同行或同列的单元格，并且包含c且候选值大于1
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (row === row1 || col === col1) {
                            if (getCandidates(sudoku, row, col).includes(c) && getCandidates(sudoku, row, col).size > 1) {
                                removeCandidate(sudoku, row, col, c);
                            }
                        }
                    }
                }
            }
        }
    }
}

// 该方法未通过测试
// class WWingSolver extends BaseSolver {
//     getSolverName() {
//         return "WWingSolver";
//     }
//
//     solver(sudoku) {
//         for (let row1 = 0; row1 < 9; row1++) {
//             for (let col1 = 0; col1 < 9; col1++) {
//                 const candidates1 = getCandidates(sudoku, row1, col1);
//                 if (candidates1.length !== 2) continue; // 必须是双值单元格
//
//                 const [x, y] = candidates1;
//
//                 for (let row2 = 0; row2 < 9; row2++) {
//                     for (let col2 = 0; col2 < 9; col2++) {
//                         if (row1 === row2 && col1 === col2) continue;
//                         const candidates2 = getCandidates(sudoku, row2, col2);
//                         if (candidates2.length !== 2) continue; // 必须是双值单元格
//
//                         // 检查两个单元格是否共享候选值
//                         if (candidates2.includes(x) && candidates2.includes(y)) {
//                             // 寻找强连接
//                             if (this.hasStrongLink(sudoku, x, row1, col1, row2, col2)) {
//                                 // 删除候选值 x
//                                 for (let row = 0; row < 9; row++) {
//                                     for (let col = 0; col < 9; col++) {
//                                         if (areBuddies(row, col, row1, col1) && areBuddies(row, col, row2, col2)) {
//                                             removeCandidate(sudoku, row, col, x);
//                                         }
//                                     }
//                                 }
//                             }
//                         }
//                     }
//                 }
//             }
//         }
//         return sudoku;
//     }
//
//     hasStrongLink(sudoku, candidate, row1, col1, row2, col2) {
//         // 检查行、列或宫中是否存在强连接
//         for (let unit = 0; unit < 9; unit++) {
//             const row = Math.floor(unit / 3) * 3;
//             const col = (unit % 3) * 3;
//             let count = 0;
//             for (let r = row; r < row + 3; r++) {
//                 for (let c = col; c < col + 3; c++) {
//                     if (getCandidates(sudoku, r, c).includes(candidate)) {
//                         count++;
//                     }
//                 }
//             }
//             if (count === 2) return true;
//         }
//         return false;
//     }
// }

class XWingSolver extends BaseSolver {
    getSolverName() {
        return "XWingSolver";
    }

    solver(sudoku) {

        // 遍历数字 1-9
        for (let val = 1; val <= 9; val++) {

            // 遍历列
            for (let j = 0; j < 9; j++) {
                let candidates = [];
                for (let i = 0; i < 9; i++) {
                    if (sudoku[i][j].size > 0 && sudoku[i][j].has(val)) {
                        candidates.push([i, j]);
                    }
                }

                if (candidates.length !== 2) continue;
                const [row1, col1] = candidates[0];
                const [row2, col2] = candidates[1];

                // 如果在同一个宫中，就不是X-Wing
                if (getBoxIndex(row1, col1) === getBoxIndex(row2, col2)) continue;

                // 判断其他列是否有相同的候选值
                for (let otherJ = 8; otherJ > j; otherJ--) {
                    if (sudoku[row1][otherJ].size > 0 && sudoku[row1][otherJ].has(val) && sudoku[row2][otherJ].size > 0 && sudoku[row2][otherJ].has(val)) {
                        // 遍历这个列，确保只有两个候选值
                        let count = 0;
                        for (let row = 0; row < 9; row++) {
                            if (sudoku[row][otherJ].size > 0 && sudoku[row][otherJ].has(val)) {
                                count++;
                            }
                        }

                        // 如果这个列有多个候选值，就跳过
                        if (count !== 2) continue;

                        // 同时不能在同一个宫中
                        if (getBoxIndex(row1, col1) === getBoxIndex(row1, otherJ)) continue;

                        // 删除这两列的其他单元格候选值
                        for (let row = 0; row < 9; row++) {
                            if (row !== row1 && row !== row2) {
                                removeCandidate(sudoku, row, j, val);
                                removeCandidate(sudoku, row, otherJ, val);
                            }
                        }

                        // 删除这两行的其他单元格候选值
                        for (let col = 0; col < 9; col++) {
                            if (col !== j && col !== otherJ) {
                                removeCandidate(sudoku, row1, col, val);
                                removeCandidate(sudoku, row2, col, val);
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }
}

class GridXYSolver extends BaseSolver {
    getSolverName() {
        return "GridXYSolver";
    }

    solver(sudoku) {
        // 遍历所有宫
        for (let boxIndex = 0; boxIndex < 9; boxIndex++) {
            const boxCells = [];
            for (let row = Math.floor(boxIndex / 3) * 3; row < Math.floor(boxIndex / 3) * 3 + 3; row++) {
                for (let col = Math.floor(boxIndex % 3) * 3; col < Math.floor(boxIndex % 3) * 3 + 3; col++) {
                    boxCells.push([row, col]);
                }
            }

            // 统计每个候选值出现的位置
            // 创建一个map，key是候选值，value是一个数组，数组中的每一个元素是一个数组，表示候选值出现的位置
            const candidateMap = new Map();

            for (let i = 0; i < boxCells.length; i++) {
                const [row, col] = boxCells[i];
                const candidates = getCandidates(sudoku, row, col);
                for (let candidate of candidates) {
                    if (!candidateMap.has(candidate)) {
                        candidateMap.set(candidate, []);
                    }
                    candidateMap.get(candidate).push([row, col]);
                }
            }

            for (let val = 1; val <= 9; val++) {
                if (!candidateMap.has(val)) continue;
                const positions = candidateMap.get(val);

                let sameRow = true;
                let sameCol = true;

                for (let i = 1; i < positions.length; i++) {
                    if (positions[i][0] !== positions[0][0]) sameRow = false;
                    if (positions[i][1] !== positions[0][1]) sameCol = false;
                    if (!sameRow && !sameCol) break;
                }

                if (sameRow || sameCol) {
                    const targetCoord = sameRow ? 0 : 1;
                    const fixedValue = sameRow ? positions[0][0] : positions[0][1];

                    for (let j = 0; j < 9; j++) {
                        if ((sameRow && getBoxIndex(fixedValue, j) === boxIndex) ||
                            (sameCol && getBoxIndex(j, fixedValue) === boxIndex)) continue;
                        const cellCandidates = getCandidates(sudoku, sameRow ? fixedValue : j, sameRow ? j : fixedValue);
                        if (cellCandidates.size > 1 && cellCandidates.has(val)) {
                            removeCandidate(sudoku, sameRow ? fixedValue : j, sameRow ? j : fixedValue, val);
                            console.log(`移除候选值 ${val} 在 ${sameRow ? `行${fixedValue}` : `列${fixedValue}`} 的非当前宫格`);
                            return sudoku; // 立即返回以保持与代码B的一致性
                        }
                    }
                }
            }
        }
        return sudoku;
    }
}

class PlaceholderSolver extends BaseSolver {
    getSolverName() {
        return "PlaceholderSolver";
    }

    solver(sudoku) {
        // 遍历9*9
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (sudoku[i][j].size === 1) {
                    continue;
                }
                // 遍历所有的候选值
                for (let val of sudoku[i][j]) {
                    let notFoundCount = 0;
                    // 检查行
                    let found = false;
                    for (let col = 0; col < 9; col++) {
                        if (col === j) continue;
                        if (sudoku[i][col].has(val)) {
                            found = true;
                            break;
                        }
                    }

                    // 如果该行中没有其他单元格包含该候选值，那么就是唯一，只保留该候选值
                    if (!found) {
                        notFoundCount++;
                    } else {
                        continue
                    }

                    // 检查列
                    found = false;
                    for (let row = 0; row < 9; row++) {
                        if (row === i) continue;
                        if (sudoku[row][j].has(val)) {
                            found = true;
                            break;
                        }
                    }

                    // 如果该列中没有其他单元格包含该候选值，那么就是唯一，只保留该候选值
                    if (!found) {
                        notFoundCount++;
                    } else {
                        continue
                    }

                    // 检查宫
                    found = false;
                    const boxIndex = getBoxIndex(i, j);
                    for (let row = Math.floor(boxIndex / 3) * 3; row < Math.floor(boxIndex / 3) * 3 + 3; row++) {
                        for (let col = Math.floor(boxIndex % 3) * 3; col < Math.floor(boxIndex % 3) * 3 + 3; col++) {
                            if (row === i && col === j) continue;
                            if (sudoku[row][col].has(val)) {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            break;
                        }
                    }

                    // 如果该宫中没有其他单元格包含该候选值，那么就是唯一，只保留该候选值
                    if (!found) {
                        notFoundCount++;
                    } else {
                        continue
                    }

                    if (notFoundCount === 3) {
                        sudoku[i][j] = new Set([val]);
                        // console.log(`在 ${i} ${j} 处找到唯一候选值 ${val}`);
                        break
                    }
                }
            }
        }

        return sudoku;
    }
}

function runAllSolversOnce(sudoku) {


    // 所有策略都执行一次
    let funcs = [
        new SimpleSolver(),
        new NakedPairsSolver(),
        new NakedTriplesSolver(),
        new NakedQuadsSolver(),
        new MiscellaneousSolver(),
        // new XYWingSolver(),
        // new YXWingSolver(),
        // new XYZWingSolver(),
        //new WWingSolver(),
        new XWingSolver(),
        new GridXYSolver(),
        new PlaceholderSolver()
    ];

    let funcNames = [
        "SimpleSolver",
        "NaekdPairsSolver",
        "NakedTriplesSolver",
        "NakedQuadsSolver",
        "MiscellaneousSolver",
        // "XYWingSolver",
        // "YXWingSolver",
        // "XYZWingSolver",
        //"WWingSolver",
        "XWingSolver",
        "GridXYSolver",
        "PlaceholderSolver"
    ];

    let changeArrays = Array.from({length: 9}, () => Array.from({length: 9}, () => new Array()));

    for (let i = 0; i < funcs.length; i++) {
        let func = funcs[i];
        let clone = cloneSudoku(sudoku);
        sudoku = func.solver(sudoku);
        checkSudokuDifferentWithString(clone, sudoku, false, funcNames[i], changeArrays);
    }

    let change = Array.from({length: 9}, () => Array.from({length: 9}, () => ""));

    for (let i = 0; i < changeArrays.length; i++) {
        for (let j = 0; j < changeArrays[i].length; j++) {
            change[i][j] = changeArrays[i][j].join("->");
        }
    }

    return {
        "sudoku": sudoku,
        "change": change
    }
}

export {
    arrayToSudoku,
    cloneSudoku,
    printSudoku,
    checkSudokuDifferent,
    SimpleSolver,
    NakedPairsSolver,
    MiscellaneousSolver,
    XYWingSolver,
    XYZWingSolver,
    //WWingSolver,
    NakedTriplesSolver,
    YXWingSolver,
    XWingSolver,
    stringToSudoku,
    GridXYSolver,
    PlaceholderSolver,
    NakedQuadsSolver,
    runAllSolversOnce,
    checkSudokuStatus
}