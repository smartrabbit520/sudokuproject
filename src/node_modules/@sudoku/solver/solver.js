function arrayToSudoku(array) {
    let sudoku = Array.from({length: 9}, () => Array.from({length: 9}, () => new Set()));

    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (array[i][j] !== 0) {
                sudoku[i][j].add(array[i][j]);
            } else {
                for (let k = 1; k <= 9; k++) {
                    sudoku[i][j].add(k);
                }
            }
        }
    }

    return sudoku;
}

function printSudoku(sudoku) {
    for (let i = 0; i < 9; i++) {
        let row = sudoku[i].map(cell => [...cell].join(', '));
        console.log(row.join(' | '));
    }
}

function cloneSudoku(sudoku) {
    return sudoku.map(row => row.map(cell => new Set(cell)));
}

function checkSudokuDifferent(sudoku1, sudoku2) {
    //console.log('Checking...')
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            if (sudoku1[i][j].size !== sudoku2[i][j].size) {
                console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                continue;
            }
            let flag = true;
            for (let num of sudoku1[i][j]) {
                if (!sudoku2[i][j].has(num)) {
                    console.log(i, j, sudoku1[i][j], sudoku2[i][j])
                    flag = false;
                }
                if (!flag) {
                    break;
                }
            }
        }
    }
    //console.log('Check done.')
}

class BaseSolver {
    getSolverName() {
        return "BaseSolver";
    }

    solver(sudoku) {
        throw new Error("Method 'solver' must be implemented.");
        return sudoku;
    }
}

class SimpleSolver extends BaseSolver {
    getSolverName() {
        return "SimpleSolver";
    }

    static mergeSetsUsingSpread = (set1, set2) => new Set([...set1, ...set2]);

    solver(sudoku) {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (sudoku[i][j].size !== 1) {
                    // 两个set交集
                    // sudoku[i][j] = SimpleSolver.mergeSetsUsingSpread(sudoku[i][j], this.getUsedNumbers(sudoku, i, j));
                    const unUsedNumbers = this.getUsedNumbers(sudoku, i, j);
                    // sudoku[i][j] = new Set([...sudoku[i][j]].filter(x => unUsedNumbers.has(x)));
                    sudoku[i][j] = unUsedNumbers;
                }
            }
        }

        return sudoku;
    }


    // 排除同行、同列和同宫已经填写的数字
    getUsedNumbers(sudoku, row, col) {
        // 获取指定行的所有数字
        const rowNumbers = new Set();
        for (let c = 0; c < 9; c++) {
            if (sudoku[row][c].size === 1) {
                rowNumbers.add([...sudoku[row][c]][0]);
            }
        }

        // 获取指定列的所有数字
        const colNumbers = new Set();
        for (let r = 0; r < 9; r++) {
            if (sudoku[r][col].size === 1) {
                colNumbers.add([...sudoku[r][col]][0]);
            }
        }

        // 获取该行和列所在的九宫格的所有数字
        const gridNumbers = new Set();
        // 计算九宫格的左上角位置
        const gridStartRow = Math.floor(row / 3) * 3;
        const gridStartCol = Math.floor(col / 3) * 3;

        for (let r = gridStartRow; r < gridStartRow + 3; r++) {
            for (let c = gridStartCol; c < gridStartCol + 3; c++) {
                if (sudoku[r][c].size === 1) {
                    gridNumbers.add([...sudoku[r][c]][0]);
                }
            }
        }

        // 合并所有的数字
        const allNumbers = new Set([...rowNumbers, ...colNumbers, ...gridNumbers]);
        let ansNumber = new Set();
        for (let i = 1; i <= 9; i++) {
            if (!allNumbers.has(i)) {
                ansNumber.add(i);
            }
        }

        return ansNumber;
    }
}

class NakedPairsSolver extends BaseSolver {

    houses = [];

    init() {
        for (let row = 0; row < 9; row++) {
            let rowSet = new Set();
            for (let i = 0; i < 9; i++) {
                rowSet.add([row, i]);
            }
            this.houses.push(rowSet);
        }

        for (let col = 0; col < 9; col++) {
            let colSet = new Set();
            for (let i = 0; i < 9; i++) {
                colSet.add([i, col]);
            }
            this.houses.push(colSet);
        }

        for (let block = 0; block < 9; block++) {
            let blockSet = new Set();
            let rowStart = Math.floor(block / 3) * 3;
            let colStart = (block % 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    blockSet.add([rowStart + r, colStart + c]);
                }
            }
            this.houses.push(blockSet);
        }
    }

    solver(sudoku) {
        this.init();

        this.prune(sudoku);

        return sudoku;
    }

    prune(sets) {
        let didSomething;
        do {
            didSomething = false;
            // 裸单一 (Naked Singles)
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (sets[i][j].size === 1) {
                        let digit = [...sets[i][j]][0];
                        for (let house of this.houses) {
                            if (house.has([i, j])) {
                                for (let [r, c] of house) {
                                    if (r !== i || c !== j) {
                                        sets[r][c].delete(digit);
                                        didSomething = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 隐藏单一 (Hidden Singles)
            for (let house of this.houses) {
                for (let digit = 1; digit <= 9; digit++) {
                    let digitPositions = [];
                    for (let [r, c] of house) {
                        if (sets[r][c].has(digit)) {
                            digitPositions.push([r, c]);
                        }
                    }
                    if (digitPositions.length === 1) {
                        let [r, c] = digitPositions[0];
                        if (sets[r][c].size > 1) {
                            sets[r][c] = new Set([digit]);
                            didSomething = true;
                        }
                    }
                }
            }
        } while (didSomething);
        return true;
    }
}

// 获取单元格的候选值
function getCandidates(sudoku, row, col) {
    return Array.from(sudoku[row][col]);
}

// 删除候选值
function removeCandidate(sudoku, row, col, candidate) {
    if(sudoku[row][col].length===1) return;
    sudoku[row][col].delete(candidate);
    // console.log("After:", row, col, sudoku[row][col]);
}

// 检查两个单元格是否在同一行、列或宫
function areBuddies(row1, col1, row2, col2) {
    return row1 === row2 || col1 === col2 || getBoxIndex(row1, col1) === getBoxIndex(row2, col2);
}

// 获取单元格所在的宫索引
function getBoxIndex(row, col) {
    return Math.floor(row / 3) * 3 + Math.floor(col / 3);
}

// 获取单元格的候选值数量
function getCandidateCount(sudoku, row, col) {
    return sudoku[row][col].size;
}

// 获取单元格的候选值掩码
function getCandidateMask(sudoku, row, col) {
    return Array.from(sudoku[row][col]).reduce((mask, cand) => mask | (1 << cand), 0);
}

// 获取候选值掩码的数量
function getMaskCount(mask) {
    return mask.toString(2).split('1').length - 1;
}

class MiscellaneousSolver extends BaseSolver {
    getSueDeCoq(sudoku) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const boxIndex = getBoxIndex(row, col);
                const intersection = new Set();
                const intersectionCandidates = new Set();

                // 找到行/列和宫的交集
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (getBoxIndex(r, c) === boxIndex && (r === row || c === col)) {
                            intersection.add([r, c]);
                            getCandidates(sudoku, r, c).forEach(cand => intersectionCandidates.add(cand));
                        }
                    }
                }

                // 检查交集的候选值数量是否满足 Sue de Coq 的条件
                if (intersectionCandidates.size < intersection.size + 2) continue;

                // 检查行/列和宫中的额外单元格
                const rowExtra = new Set();
                const rowExtraCandidates = new Set();
                const boxExtra = new Set();
                const boxExtraCandidates = new Set();

                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (r === row || c === col) {
                            if (!intersection.has([r, c])) {
                                rowExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => rowExtraCandidates.add(cand));
                            }
                        }
                        if (getBoxIndex(r, c) === boxIndex) {
                            if (!intersection.has([r, c])) {
                                boxExtra.add([r, c]);
                                getCandidates(sudoku, r, c).forEach(cand => boxExtraCandidates.add(cand));
                            }
                        }
                    }
                }

                // 检查是否满足 Sue de Coq 的条件
                const rowExtraValid = Array.from(rowExtraCandidates).every(cand => intersectionCandidates.has(cand));
                const boxExtraValid = Array.from(boxExtraCandidates).every(cand => intersectionCandidates.has(cand));

                if (rowExtraValid && boxExtraValid) {
                    // 删除候选值
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (!intersection.has([r, c]) && (r === row || c === col || getBoxIndex(r, c) === boxIndex)) {
                                Array.from(intersectionCandidates).forEach(cand => {
                                    if (!rowExtraCandidates.has(cand) && !boxExtraCandidates.has(cand)) {
                                        removeCandidate(sudoku, r, c, cand);
                                    }
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    solver(sudoku) {
        this.getSueDeCoq(sudoku)
        return sudoku
    }

    getSolverName() {
        return "Miscellaneous Solver"
    }

    test() {
        const sudoku = [
            [6, 0, 0, 0, 0, 0, 0, 0, 8],
            [5, 0, 0, 9, 0, 8, 0, 0, 7],
            [8, 2, 0, 0, 0, 1, 0, 3, 0],
            [3, 4, 0, 2, 0, 9, 0, 8, 0],
            [2, 0, 0, 0, 8, 0, 3, 0, 0],
            [1, 8, 0, 3, 0, 7, 0, 2, 5],
            [7, 5, 0, 4, 0, 0, 0, 9, 2],
            [9, 0, 0, 0, 0, 5, 0, 0, 4],
            [4, 0, 0, 0, 9, 0, 0, 0, 3]
        ];

        let sudokuBoard = new SudokuBoard(sudoku);

        sudokuBoard = new NakedPairsSolver().solver(sudokuBoard);

        //let temp = sudokuBoard.board.map(row => row.map(cell => new Set(cell)));
        let tempBoard = sudokuBoard.cloneBoard()

        this.solver(sudokuBoard);

        // sudokuBoard.checkDiff(temp);
        sudokuBoard.checkDiff(tempBoard.board);
    }
}

class XYWingSolver extends BaseSolver {

    getSolverName() {
        return "XYWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 2) continue; // 必须是双值单元格

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享一个候选值
                        const sharedCandidates = candidates1.filter(c => candidates2.includes(c));
                        if (sharedCandidates.length !== 1) continue;

                        const z = sharedCandidates[0];
                        const x = candidates1.find(c => c !== z);
                        const y = candidates2.find(c => c !== z);

                        // 寻找第三个单元格
                        for (let row3 = 0; row3 < 9; row3++) {
                            for (let col3 = 0; col3 < 9; col3++) {
                                if (row3 === row1 && col3 === col1) continue;
                                if (row3 === row2 && col3 === col2) continue;
                                const candidates3 = getCandidates(sudoku, row3, col3);
                                if (candidates3.length !== 2) continue; // 必须是双值单元格

                                // 检查第三个单元格是否包含 y 和 z
                                if (!candidates3.includes(y) || !candidates3.includes(z)) continue;

                                // 检查第三个单元格是否与第一个单元格共享 y
                                if (!areBuddies(row1, col1, row3, col3)) continue;

                                // 找到 XY-Wing，删除候选值 z
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row2, col2) && areBuddies(row, col, row3, col3)) {
                                            removeCandidate(sudoku, row, col, z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }

}

class XYZWingSolver extends BaseSolver {
    getSolverName() {
        return "XYZWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 3) continue; // 必须是三值单元格

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享两个候选值
                        const sharedCandidates = candidates1.filter(c => candidates2.includes(c));
                        if (sharedCandidates.length !== 2) continue;

                        const z = sharedCandidates[0];
                        const x = candidates1.find(c => c !== z);
                        const y = candidates2.find(c => c !== z);

                        // 寻找第三个单元格
                        for (let row3 = 0; row3 < 9; row3++) {
                            for (let col3 = 0; col3 < 9; col3++) {
                                if (row3 === row1 && col3 === col1) continue;
                                if (row3 === row2 && col3 === col2) continue;
                                const candidates3 = getCandidates(sudoku, row3, col3);
                                if (candidates3.length !== 2) continue; // 必须是双值单元格

                                // 检查第三个单元格是否包含 y 和 z
                                if (!candidates3.includes(y) || !candidates3.includes(z)) continue;

                                // 检查第三个单元格是否与第一个单元格共享 y
                                if (!areBuddies(row1, col1, row3, col3)) continue;

                                // 找到 XYZ-Wing，删除候选值 z
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row2, col2) && areBuddies(row, col, row3, col3)) {
                                            removeCandidate(sudoku, row, col, z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return sudoku;
    }
}

class WWingSolver extends BaseSolver {
    getSolverName() {
        return "WWingSolver";
    }

    solver(sudoku) {
        for (let row1 = 0; row1 < 9; row1++) {
            for (let col1 = 0; col1 < 9; col1++) {
                const candidates1 = getCandidates(sudoku, row1, col1);
                if (candidates1.length !== 2) continue; // 必须是双值单元格

                const [x, y] = candidates1;

                for (let row2 = 0; row2 < 9; row2++) {
                    for (let col2 = 0; col2 < 9; col2++) {
                        if (row1 === row2 && col1 === col2) continue;
                        const candidates2 = getCandidates(sudoku, row2, col2);
                        if (candidates2.length !== 2) continue; // 必须是双值单元格

                        // 检查两个单元格是否共享候选值
                        if (candidates2.includes(x) && candidates2.includes(y)) {
                            // 寻找强连接
                            if (this.hasStrongLink(sudoku, x, row1, col1, row2, col2)) {
                                // 删除候选值 x
                                for (let row = 0; row < 9; row++) {
                                    for (let col = 0; col < 9; col++) {
                                        if (areBuddies(row, col, row1, col1) && areBuddies(row, col, row2, col2)) {
                                            removeCandidate(sudoku, row, col, x);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return sudoku;
    }

    hasStrongLink(sudoku, candidate, row1, col1, row2, col2) {
        // 检查行、列或宫中是否存在强连接
        for (let unit = 0; unit < 9; unit++) {
            const row = Math.floor(unit / 3) * 3;
            const col = (unit % 3) * 3;
            let count = 0;
            for (let r = row; r < row + 3; r++) {
                for (let c = col; c < col + 3; c++) {
                    if (getCandidates(sudoku, r, c).includes(candidate)) {
                        count++;
                    }
                }
            }
            if (count === 2) return true;
        }
        return false;
    }
}

export {
    arrayToSudoku, cloneSudoku, printSudoku, checkSudokuDifferent,
    SimpleSolver, NakedPairsSolver, MiscellaneousSolver, XYWingSolver, XYZWingSolver, WWingSolver
}