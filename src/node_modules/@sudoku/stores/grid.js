import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { decodeSencode, encodeSudoku, decodeSencodeDirect } from '@sudoku/sencode';
import { currentValueStore ,num} from '@sudoku/stores/currentValueStore';
function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,
		generate(difficulty) {
			grid.set(generateSudoku(difficulty));
		},
		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},
		decodeSencodeDirect(sencode) {
			grid.set(decodeSencodeDirect(sencode));
		},
		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();

// Gridsource 改为 writable store，这样可以被其他文件访问
export const Gridsource = writable([
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "],
	[" ", " ", " ", " ", " ", " ", " ", " ", " "]
]);

function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);
	const disabledCandidates = writable(new Map());
	const undoStack = [];
	const redoStack = [];
	const isUndoable = writable(false);
	const isRedoable = writable(false);
	const isBackToBranchable = writable(false);
	const branchStack = [];
	const branchwrongStack = [];
	const candidateonlySet=writable(new Set());
	function updateIsUndoable() {
		isUndoable.set(undoStack.length > 0);
	}
	function updateisRedoable() {
		isRedoable.set(redoStack.length > 0);
	}
	function updateisBackToBranchable() {
		isBackToBranchable.set(branchStack.length);
	}
	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	// 添加重置操作状态的方法
	function resetOperationStates() {
		// 清空所有栈
		undoStack.length = 0;
		redoStack.length = 0;
		branchStack.length = 0;
		branchwrongStack.length = 0;

		// 重置所有状态
		isUndoable.set(false);
		isRedoable.set(false);
		isBackToBranchable.set(false);

		// 清空禁用候选值
		disabledCandidates.set(new Map());
		//
		// num.set(0);
	}

	return {
		subscribe: userGrid.subscribe,

		set: (pos, value, branch = false) => {
			userGrid.update($userGrid => {
				// $userGrid[pos.y][pos.x] = value;
				// return $userGrid;
				// 记录当前值以支持撤回
				const previousValue = $userGrid[pos.y][pos.x];
				undoStack.push({ pos, value: previousValue });
				console.log({ pos, value: previousValue });
				if (branch) {
					branchStack.push(undoStack.length - 1);
					// console.log(branchStack);
					branchwrongStack.push({ pos, value: value });
					// console.log(branchwrongStack);
				}
				// 清空重做栈
				redoStack.length = 0;
				// 设置新值
				$userGrid[pos.y][pos.x] = value;
				updateIsUndoable();
				updateisRedoable();
				updateisBackToBranchable();
				return $userGrid;
			});
		},

		applyHint: () => {
			console.log("applyHint");
			userGrid.update($userGrid => {
				const { grid, gridsource } = solveSudoku($userGrid);
				// 更新 Gridsource store
				Gridsource.set(gridsource);  // 更新 Gridsource
				// 更新 userGrid 的值
				// for (let i = 0; i < 9; i++) {
				// 	for (let j = 0; j < 9; j++) {
				// 		const previousValue = $userGrid[i][j];
				// 		let pos = { x: j, y: i };
				// 		if (grid[i][j] != previousValue)
				// 			undoStack.push({ pos, value: 0 });

				// 		// 清空重做栈
				// 		redoStack.length = 0;
				// 		// 设置新值
				// 		$userGrid[i][j] = grid[i][j];
				// 		updateIsUndoable();
				// 		updateisRedoable();
				// 		updateisBackToBranchable();
				// 	}
				// }
				// candidateonlySet.set(new Set());

				for(let i=0;i<9;i++){
					for(let j=0;j<9;j++){
						// console.log(grid[i][j]);
						if(grid[i][j]===1) {
							candidateonlySet.update($candidateonlySet => {
								$candidateonlySet.add(i+','+j);
								for(let value of $candidateonlySet){
									// console.log($candidateonlySet);
								}
								return $candidateonlySet;
							});
						}
					}
				}
				
				return $userGrid;
			});
		},
		undo: () => {
			if (undoStack.length > 0) {
				const { pos, value } = undoStack.pop();
				userGrid.update($userGrid => {
					// 记录当前值以支持重做
					const currentValue = $userGrid[pos.y][pos.x];
					redoStack.push({ pos, value: currentValue });
					// 恢复之前的值
					$userGrid[pos.y][pos.x] = value;
					updateIsUndoable();
					updateisRedoable();
					updateisBackToBranchable();
					return $userGrid;
				});
				// 检查是否需要弹出branchStack中的标记
				if (branchStack.length > 0 && undoStack.length <= branchStack[branchStack.length - 1]) {
					branchStack.pop();
				}
			}
		},
		redo: () => {
			if (redoStack.length > 0) {
				const { pos, value } = redoStack.pop();
				userGrid.update($userGrid => {
					// 记录当前值以支持撤回
					const currentValue = $userGrid[pos.y][pos.x];
					undoStack.push({ pos, value: currentValue });
					// 恢复之前的值
					$userGrid[pos.y][pos.x] = value;

					updateIsUndoable();
					updateisRedoable();
					updateisBackToBranchable();
					return $userGrid;
				});
			}
		},
		backToBranch: () => {
			if (branchStack.length > 0) {
				const branchIndex = branchStack.pop();
				let { pos, value } = { pos: 0, value: 0 };
				while (undoStack.length > branchIndex) {
					({ pos, value } = undoStack.pop());
					userGrid.update($userGrid => {
						const currentValue = $userGrid[pos.y][pos.x];
						redoStack.push({ pos, value: currentValue });
						$userGrid[pos.y][pos.x] = value;

						return $userGrid;
					});
				}

				const wrongMove = branchwrongStack.pop();
				if (wrongMove) {
					const cellKey = `${wrongMove.pos.y},${wrongMove.pos.x}`;
					// 更新禁用的候选值
					disabledCandidates.update($disabledCandidates => {
						// 如果该单元格已经有禁用值的集合，就获取它，���则创建新的 Set
						const disabledSet = $disabledCandidates.has(cellKey)
							? $disabledCandidates.get(cellKey)
							: new Set();

						// 将新的禁用值添加到集合中
						disabledSet.add(wrongMove.value);

						// 更新 Map
						$disabledCandidates.set(cellKey, disabledSet);
						return $disabledCandidates;
					});
					// disabledCandidates.subscribe($disabledCandidates => {
					//         // 访问 Map 的值
					//         $disabledCandidates.forEach((value, key) => {
					//             console.log(`Key: ${key}, Value: ${value}`);
					//         });
					// 	 });
				}


				userGrid.update($userGrid => {
					const { grid, gridsource } = solveSudoku($userGrid);

					// 更新 Gridsource store
					Gridsource.set(gridsource);  // 更新 Gridsource
					// 更新 userGrid 的值
		
					return $userGrid;
				});

				updateIsUndoable();
				updateisRedoable();
				updateisBackToBranchable();
			}
		},
		isUndoable,
		isRedoable,
		isBackToBranchable,
		undoStack,
		redoStack,
		branchStack,
		// 导出禁用候选值的状态
		disabledCandidates,
		resetOperationStates,  // 导出重置方法
		candidateonlySet, //导出集合
	};
}

export const userGrid = createUserGrid();
export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// 检查行
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// 检查列
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// 检查小格子
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}
		}
	}

	return _invalidCells;
}, []);
