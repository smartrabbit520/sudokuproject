import solve from '@mattflow/sudoku-solver';
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { getSudoku } from 'fake-sudoku-puzzle-generator';
import { candidates } from '@sudoku/stores/candidates';
import { cursor } from '@sudoku/stores/cursor';
import {runAllSolversOnce,  arrayToSudoku,cloneSudoku} from '@sudoku/solver/solver.js';
/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */

export function generateSudoku(difficulty = 'easy') {
	const sudoku = getSudoku(difficulty);
	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}
	return sudoku;
}

/**
 * @param {number[][]} sudoku
 */
export function solveSudoku(sudoku) {
		
		//判断两个集合是否相等
		function areSetsEqual(set1, set2) {
		    // 如果两个集合的大小不同，直接返回 false
		    if (set1.size !== set2.size) return false;
		
		    // 使用迭代检查 set1 中的每个元素是否都存在于 set2 中
		    for (let item of set1) {
		        if (!set2.has(item)) {
		            return false;
		        }
		    }
		    return true;
		}
	
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];
	let gridsource = [
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "],
	  [" ", " ", " ", " ", " ", " ", " ", " ", " "]
	];


	let sudokuArray = arrayToSudoku(sudoku);
	let sudoku1 = cloneSudoku(sudokuArray);
	// let sudoku1 = new SimpleSolver().solver((otherSudoku));
	// let sudoku0 = new SimpleSolver().solver(otherSudoku);
	// let sudoku00 = new XYWingSolver().solver((sudoku0));
	// let sudoku000 = new NakedPairsSolver().solver((sudoku00));
	// let sudoku1 = new MiscellaneousSolver().solver((sudoku000));


	const before = sudoku1.map(row => row.map(cell => new Set(cell))); // 使用深度克隆，确保 before 是一个独立副本
	let res = runAllSolversOnce(sudoku1);
	sudoku1=res['sudoku'];
	gridsource=res['change'];
	
	//先清空candidates
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
			let [row, col] = GRID_COORDS[cell];
			let pos={x:row,y:col};
			candidates.clear(pos);
			console.log(candidates[pos.y+','+pos.x]);
			
	}
	
	// 打印交换后的 sudoku1
	for (let i = 0; i < 9; i++) {
		 let temp="";
	    for (let j = 0; j < 9; j++) {
	        // 交换 (i, i) 和 (j, j)
	     for(let value of sudoku1[i][j]){
			 temp=temp+value+',';
		 }
		  temp+="|";
	    }
		 console.log(temp);
	}
	

		
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		const [row, col] = GRID_COORDS[cell];
		let pos={x:col,y:row};
		if(sudoku1[row][col].size===1&&before[row][col].size>1){
			grid[row][col] = 1;
		}
		if(before[row][col].size!==1){
			for (let value of sudoku1[row][col]) {
				candidates.add(pos, value);
				// console.log("wode"+candidates[pos.y + ',' + pos.x]);
			}
		}

	}

	return {
		grid:grid, //在原状态新增的唯一候选值上为1
		gridsource:gridsource
	};
}

/**
 * @param {number[][]} sudoku
 */
// export function printSudoku(sudoku) {
// 	let out = '╔═══════╤═══════╤═══════╗\n';

// 	for (let row = 0; row < SUDOKU_SIZE; row++) {
// 		if (row !== 0 && row % BOX_SIZE === 0) {
// 			out += '╟───────┼───────┼───────╢\n';
// 		}

// 		for (let col = 0; col < SUDOKU_SIZE; col++) {
// 			if (col === 0) {
// 				out += '║ ';
// 			} else if (col % BOX_SIZE === 0) {
// 				out += '│ ';
// 			}

// 			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';

// 			if (col === SUDOKU_SIZE - 1) {
// 				out += '║';
// 			}
// 		}

// 		out += '\n';
// 	}

// 	out += '╚═══════╧═══════╧═══════╝';

// 	console.log(out);
// }